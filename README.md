# ToDo-SchemaOrg-Delphi

Our mission is translate schemas.org to pascal code and create some useful tools.

[http://schema.org/](http://schema.org/) works to define a ontological model of classes for structured data on the Internet, on web pages, in email messages, and [more](http://schema.org/).

The goal is generate the full documented Pascal code interfaces and abstract classes.


** Why **

The objective is to explore what can do schema.org for us.The simple fact of seeing the classes represented in pascal code can better understand schema.org to delphi programmers and stimulate different uses.

It is in experimental phase ,but we what use schema.org model for own development. Really we only use about 20 or 30 classes from the more than 1000.

But you can have multiple use cases.

* To serve an ontological basis for your classes.

    * Perhaps is not very practical to base all your classes in Schema.org. Is very difficult and dangerous to change everything at once,is better start with something as simple possible. Make small experiments and look where can be useful. Is better to think in schema.org as a future second world for you program

    * If reuse schema.org is too complex, you can also Fork the code and remove properties that not going to use, leaving minimal classes and properties. Do not recommend you change a name if you want your code to be shared. I not recommend adding properties to the basic classes, if no other way, creates a new inherited class, or better yet composite or aggregate.

    * You can also just to use the names of properties or classes in "partial" form so they can be better understood.

    * Relate your classes through an aggregation pattern or Map

* Having a common pattern among different projects, programmers, companies.

    * Rest microservices or create services that use a common vocabulary.

    * If other programmers use the same class scheme makes it easier to integrate projects.

* Database knowledge.

    * The software "future" needs a model as much consensus possible, to interrelate with other things. Use common names and concepts. Locate resources and use them correctly as quickly possible. Our programs have to "know" more about the rest of the world.

How?

Since schema.org is a class tree, these can be represented by pascal code. So far we can be "quite" agree. 

The problem is that although everything is a lot specified, create code involves many possible paths. We each have our preferences.

Beginning with trivial things: how we name things, what style we write (indentation, spaces, line spacing), how organize or divide into classes and units, etc ....

And ending with more complex things like architecture class tree, patterns, injection mechanisms, ORM, performance, and overall adaptation to different contexts of use.

 	We canâ€™t do miracles, and sure you find defects. or maybe you want othen style 

Roadmap 

0.1) Generate the first version to serve a starting point for Open developments.

        Schema_Interfaces.pas

0.2) The first version is generated by a program that not yet incorporated the model schema.org classes. The intention is to use the first Schema_Interfaces.pas to refactor legacy version and create a new version that incorporates the new structure. 

** MetaCiclos **
  Every time we can generate the schema_interface again. 
  If nothing change in the model or in the generator, the code must to be the same.
  If we add a new feature in the generator then the Schema_interface.pas can change , then we must repit the cycle.

0.3) Generate code for other languages. JavaScript ...

0.4) Create tools that use a common class model and generate code allow for more specialized use contexts.

0.5) DDD)

0.6  Interactive Web to generate code for different languages, libraries, etc ...

0.7) Docker.

0.8) Cloud.

0.9  offer commercial services.

	
